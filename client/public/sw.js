import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, NetworkFirst, CacheFirst } from 'workbox-strategies';

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache the Google Maps API
registerRoute(
  /.*maps\.googleapis\.com\/maps\/api\/js/,
  new NetworkFirst({
    cacheName: 'google-maps',
  })
);

// Cache map tiles with a Cache First strategy
registerRoute(
  /.*\.(?:png|jpg|jpeg|svg|gif|webp|ico)/,
  new CacheFirst({
    cacheName: 'images',
  })
);

// Cache API requests with a Stale While Revalidate strategy
registerRoute(
  /\/api\/.*/,
  new StaleWhileRevalidate({
    cacheName: 'api-cache',
  })
);

// Cache styles, scripts, and fonts
registerRoute(
  /\.(?:css|js)$/,
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Listen for sync events to sync pending operations
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-reports') {
    event.waitUntil(syncPendingReports());
  } else if (event.tag === 'sync-supports') {
    event.waitUntil(syncPendingSupports());
  }
});

// Function to sync pending reports
async function syncPendingReports() {
  try {
    const db = await openIDB();
    const pendingReports = await db.getAll('pendingReports');
    
    // Try to submit each pending report
    for (const report of pendingReports) {
      try {
        const formData = new FormData();
        
        // Add fields to FormData
        Object.keys(report).forEach(key => {
          if (key !== 'id' && key !== 'photo') {
            formData.append(key, report[key]);
          }
        });
        
        // Add photo if available
        if (report.photo) {
          formData.append('photo', report.photo);
        }
        
        // Attempt to submit the report
        const response = await fetch('/api/issues', {
          method: 'POST',
          body: formData,
        });
        
        if (response.ok) {
          // If successful, remove from pending queue
          await db.delete('pendingReports', report.id);
        }
      } catch (error) {
        console.error('Failed to sync report:', error);
      }
    }
  } catch (error) {
    console.error('Error syncing pending reports:', error);
  }
}

// Function to sync pending supports
async function syncPendingSupports() {
  try {
    const db = await openIDB();
    const pendingSupports = await db.getAll('pendingSupports');
    
    // Try to submit each pending support
    for (const support of pendingSupports) {
      try {
        // Attempt to submit the support
        const response = await fetch(`/api/issues/${support.issueId}/support`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            deviceId: support.deviceId,
          }),
        });
        
        if (response.ok) {
          // If successful, remove from pending queue
          await db.delete('pendingSupports', support.id);
        }
      } catch (error) {
        console.error('Failed to sync support:', error);
      }
    }
  } catch (error) {
    console.error('Error syncing pending supports:', error);
  }
}

// Helper to open IndexedDB
async function openIDB() {
  // This is a simplified version - we'll implement the full DB in a separate file
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('reportr', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}